.globl	constructor
.public	constructor
.type	constructor, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7_with_init_storage$
}
IF
;; constructor protection
GETGLOB 6
THROWIF 51
PUSHINT 1
SETGLOB 6
;; end constructor protection
; Decode input parameters
; Decode external_owner_pubkey_
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode internal_owner_address_
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: external_owner_pubkey_
;; param: internal_owner_address_
; constructor TokenEventProxy
;; push identifier error_define_public_key_or_owner_address
GETGLOB 27
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; push identifier external_owner_pubkey_
PUSH S2
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member value
	;; push identifier internal_owner_address_
	PUSH S1
	PARSEMSGADDR
	INDEX 3
	PLDU 256
	EQINT 0
}
IF
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	;; push identifier external_owner_pubkey_
	PUSH S2
	EQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member value
		;; push identifier internal_owner_address_
		PUSH S1
		PARSEMSGADDR
		INDEX 3
		PLDU 256
		NEQINT 0
	}
	IF
}
IFNOT
THROWANYIFNOT
ACCEPT
; expValue
; end expValue
;; push identifier external_owner_pubkey_
PUSH S1
; colValue
SETGLOB 13
; end colValue
; expValue
; end expValue
;; push identifier internal_owner_address_
DUP
; colValue
SETGLOB 14
; end colValue
; expValue
; end expValue
PUSHINT 0
; colValue
SETGLOB 15
; end colValue
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
; expValue
; end expValue
; colValue
SETGLOB 16
; end colValue
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
; expValue
; end expValue
; colValue
SETGLOB 17
; end colValue
;; get member balance
GETPARAM 7
INDEX 0
; expValue
; end expValue
; colValue
SETGLOB 20
; end colValue
DROP2
; end constructor TokenEventProxy
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	broxusBridgeCallback
.public	broxusBridgeCallback
.type	broxusBridgeCallback, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode eventData
;; decode struct EthereumEventInitData eventData
;; decode EthereumEventInitData.eventTransaction
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
;; decode EthereumEventInitData.eventIndex
LDUQ 32
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 32
}
IFNOT
;; decode EthereumEventInitData.eventData
;; decode TvmCell
DUP
SREFS
EQINT 1
PUSHCONT {
	LDREF
	ENDS
	CTOS
}
IF
LDREF
;; decode EthereumEventInitData.eventBlockNumber
LDUQ 32
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 32
}
IFNOT
;; decode EthereumEventInitData.eventBlock
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
;; decode EthereumEventInitData.ethereumEventConfiguration
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
;; decode EthereumEventInitData.requiredConfirmations
LDUQ 16
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 16
}
IFNOT
;; decode EthereumEventInitData.requiredRejects
LDUQ 16
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 16
}
IFNOT
;; decode EthereumEventInitData.proxyAddress
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
;; decode EthereumEventInitData.configurationMeta
;; decode TvmCell
DUP
SBITREFS
EQINT 1
SWAP
EQINT 0
AND
PUSHCONT {
	LDREF
	ENDS
	CTOS
}
IF
LDREF
;; build struct EthereumEventInitData ss:11
BLKSWAP 10, 1
TUPLE 10
SWAP
; Decode gasBackAddress
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: eventData
;; param: gasBackAddress
; function broxusBridgeCallback
;; push identifier error_paused
GETGLOB 28
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; !
;; push identifier paused
GETGLOB 22
NOT
THROWANYIFNOT
;; push identifier eventData
PUSH S1
;; param: initData
; function getExpectedEventAddress
NEWDICT
;; push identifier ethereum_event_deploy_pubkey
GETGLOB 15
NEWC
STU 256
PUSHINT 0
ROT
PUSHINT 64
DICTUSETB
;; push identifier initData
PUSH S1
UNTUPLE 10
NEWC
NEWC
PUSH S3
STSLICER
PUSH S2
STREFR
STBREFR
PUSH S10
STUR 256
PUSH S9
STUR 32
PUSH S8
STREFR
PUSH S7
STUR 32
PUSH S6
STUR 256
PUSH S5
STSLICER
PUSH S4
STUR 16
PUSH S3
STUR 16
XCHG s10
BLKDROP 10
ENDC
PUSHINT 1
ROT
PUSHINT 64
DICTUSETREF
NEWC
STDICT
ENDC
;; push identifier ethereum_event_code
GETGLOB 11
NEWC
STSLICECONST x2_
STOPTREF
STOPTREF
STZERO
ENDC
;; decl: stateInit
;; return
;; push identifier stateInit
DUP
HASHCU
NEWC
STSLICECONST x801_
STU 256
ENDC
CTOS
NIP
NIP
; end function getExpectedEventAddress
;; decl: expectedSenderAddress
;; push identifier error_message_sender_is_not_valid_event
GETGLOB 25
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; push identifier expectedSenderAddress
PUSH S1
;; get member sender
GETGLOB 9
SDEQ
THROWANYIFNOT
;; get member ethereumEventConfiguration
;; push identifier eventData
PUSH S2
INDEX 5
;; push identifier ethereum_event_configuration_address
GETGLOB 16
SDEQ
THROWIFNOT 100
;; get member proxyAddress
;; push identifier eventData
PUSH S2
INDEX 8
MYADDR
SDEQ
THROWIFNOT 100
;; get member value
;; push identifier token_root_address
GETGLOB 17
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
THROWIFNOT 100
;; push identifier start_gas_balance
GETGLOB 20
;; get member balance
GETPARAM 7
INDEX 0
;; get member value
CALL $message_balance_macro$
;; -
SUB
UFITS 128
MAX
PUSHINT 2
RAWRESERVE
;; get member eventData
;; push identifier eventData
PUSH S2
INDEX 2
CTOS
LDU 128
LDI 8
LDU 256
LDU 256
; colValue
DROP
;; decl: tokens
;; decl: wid
;; decl: owner_addr
;; decl: owner_pubkey
;; address.makeAddrStd()
;; push identifier owner_addr
PUSH S1
;; push identifier wid
PUSH S3
NEWC
STSLICECONST x9_
STI 8
STU 256
ENDC
CTOS
;; decl: owner_address
;; push identifier error_message_not_valid_payload
GETGLOB 26
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; push identifier tokens
PUSH S5
GTINT 0
THROWANYIFNOT
;; push identifier error_message_not_valid_payload
GETGLOB 26
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; push identifier owner_pubkey
PUSH S2
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member value
	;; push identifier owner_address
	PUSH S1
	PARSEMSGADDR
	INDEX 3
	PLDU 256
	EQINT 0
}
IF
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	;; push identifier owner_pubkey
	PUSH S2
	EQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member value
		;; push identifier owner_address
		PUSH S1
		PARSEMSGADDR
		INDEX 3
		PLDU 256
		NEQINT 0
	}
	IF
}
IFNOT
THROWANYIFNOT
;; Remote call IRootTokenContract.deployWallet
;; push identifier token_root_address
GETGLOB 17
NEWC
STSLICECONST x62_
STSLICE
PUSHINT 109
STZEROES
STSLICECONST 0
STSLICECONST 1
NEWC
STSLICECONST x66211c6f
;; tokens
;; push identifier tokens
PUSH S6
STUR 128
;; deploy_grams
;; push identifier settings_deploy_wallet_grams
GETGLOB 19
STUR 128
;; wallet_public_key
;; push identifier owner_pubkey
PUSH S3
STUR 256
;; owner_address
;; push identifier owner_address
PUSH S2
STSLICER
NEWC
;; gas_back_address
;; push identifier gasBackAddress
PUSH S9
STSLICER
STBREFR
STBREFR
ENDC
PUSHINT 128
SENDRAWMSG
BLKDROP 8
; end function broxusBridgeCallback
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	broxusBridgeCallback_internal
.type	broxusBridgeCallback_internal, @function
;; param: eventData
;; param: gasBackAddress
; function broxusBridgeCallback
;; push identifier error_paused
GETGLOB 28
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; !
;; push identifier paused
GETGLOB 22
NOT
THROWANYIFNOT
;; push identifier eventData
PUSH S1
;; param: initData
; function getExpectedEventAddress
NEWDICT
;; push identifier ethereum_event_deploy_pubkey
GETGLOB 15
NEWC
STU 256
PUSHINT 0
ROT
PUSHINT 64
DICTUSETB
;; push identifier initData
PUSH S1
UNTUPLE 10
NEWC
NEWC
PUSH S3
STSLICER
PUSH S2
STREFR
STBREFR
PUSH S10
STUR 256
PUSH S9
STUR 32
PUSH S8
STREFR
PUSH S7
STUR 32
PUSH S6
STUR 256
PUSH S5
STSLICER
PUSH S4
STUR 16
PUSH S3
STUR 16
XCHG s10
BLKDROP 10
ENDC
PUSHINT 1
ROT
PUSHINT 64
DICTUSETREF
NEWC
STDICT
ENDC
;; push identifier ethereum_event_code
GETGLOB 11
NEWC
STSLICECONST x2_
STOPTREF
STOPTREF
STZERO
ENDC
;; decl: stateInit
;; return
;; push identifier stateInit
DUP
HASHCU
NEWC
STSLICECONST x801_
STU 256
ENDC
CTOS
NIP
NIP
; end function getExpectedEventAddress
;; decl: expectedSenderAddress
;; push identifier error_message_sender_is_not_valid_event
GETGLOB 25
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; push identifier expectedSenderAddress
PUSH S1
;; get member sender
GETGLOB 9
SDEQ
THROWANYIFNOT
;; get member ethereumEventConfiguration
;; push identifier eventData
PUSH S2
INDEX 5
;; push identifier ethereum_event_configuration_address
GETGLOB 16
SDEQ
THROWIFNOT 100
;; get member proxyAddress
;; push identifier eventData
PUSH S2
INDEX 8
MYADDR
SDEQ
THROWIFNOT 100
;; get member value
;; push identifier token_root_address
GETGLOB 17
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
THROWIFNOT 100
;; push identifier start_gas_balance
GETGLOB 20
;; get member balance
GETPARAM 7
INDEX 0
;; get member value
CALL $message_balance_macro$
;; -
SUB
UFITS 128
MAX
PUSHINT 2
RAWRESERVE
;; get member eventData
;; push identifier eventData
PUSH S2
INDEX 2
CTOS
LDU 128
LDI 8
LDU 256
LDU 256
; colValue
DROP
;; decl: tokens
;; decl: wid
;; decl: owner_addr
;; decl: owner_pubkey
;; address.makeAddrStd()
;; push identifier owner_addr
PUSH S1
;; push identifier wid
PUSH S3
NEWC
STSLICECONST x9_
STI 8
STU 256
ENDC
CTOS
;; decl: owner_address
;; push identifier error_message_not_valid_payload
GETGLOB 26
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; push identifier tokens
PUSH S5
GTINT 0
THROWANYIFNOT
;; push identifier error_message_not_valid_payload
GETGLOB 26
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; push identifier owner_pubkey
PUSH S2
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member value
	;; push identifier owner_address
	PUSH S1
	PARSEMSGADDR
	INDEX 3
	PLDU 256
	EQINT 0
}
IF
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	;; push identifier owner_pubkey
	PUSH S2
	EQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member value
		;; push identifier owner_address
		PUSH S1
		PARSEMSGADDR
		INDEX 3
		PLDU 256
		NEQINT 0
	}
	IF
}
IFNOT
THROWANYIFNOT
;; Remote call IRootTokenContract.deployWallet
;; push identifier token_root_address
GETGLOB 17
NEWC
STSLICECONST x62_
STSLICE
PUSHINT 109
STZEROES
STSLICECONST 0
STSLICECONST 1
NEWC
STSLICECONST x66211c6f
;; tokens
;; push identifier tokens
PUSH S6
STUR 128
;; deploy_grams
;; push identifier settings_deploy_wallet_grams
GETGLOB 19
STUR 128
;; wallet_public_key
;; push identifier owner_pubkey
PUSH S3
STUR 256
;; owner_address
;; push identifier owner_address
PUSH S2
STSLICER
NEWC
;; gas_back_address
;; push identifier gasBackAddress
PUSH S9
STSLICER
STBREFR
STBREFR
ENDC
PUSHINT 128
SENDRAWMSG
BLKDROP 8
; end function broxusBridgeCallback

.globl	burnCallbackV1
.public	burnCallbackV1
.type	burnCallbackV1, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
; Decode 
;; decode TvmCell
DUP
SBITREFS
EQINT 1
SWAP
EQINT 0
AND
PUSHCONT {
	LDREF
	ENDS
	CTOS
}
IF
LDREF
; Decode sender_public_key
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode sender_address
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode wallet_address
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: tokens
;; param: 
;; param: sender_public_key
;; param: sender_address
;; param: wallet_address
; function burnCallbackV1
;; push identifier start_gas_balance
GETGLOB 20
;; get member balance
GETPARAM 7
INDEX 0
;; get member value
CALL $message_balance_macro$
;; -
SUB
UFITS 128
MAX
PUSHINT 2
RAWRESERVE
FALSE
;; decl: is_outdated_tokens
; for
PUSHINT 0
;; decl: i
PUSHCONT {
	;; push identifier i
	DUP
	;; get member length
	;; push identifier outdated_token_roots
	GETGLOB 12
	INDEX 0
	;; <
	LESS
}
PUSHCONT {
	; expValue
	; end expValue
	;; push identifier is_outdated_tokens
	PUSH S1
	;; short-circuiting ||
	DUP
	PUSHCONT {
		DROP
		;; index
		;; push identifier i
		DUP
		;; push identifier outdated_token_roots
		GETGLOB 12
		INDEX 1
		PUSHINT 32
		DICTUGET
		THROWIFNOT 50
		;; get member sender
		GETGLOB 9
		SDEQ
	}
	IFNOT
	; colValue
	POP S2
	; end colValue
	;; ++
	; expValue
	; end expValue
	INC
	; colValue
	; end colValue
}
WHILE
DROP
; end for
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
;; decl: send_gas_to
;; if
;; get member value
;; push identifier sender_address
PUSH S3
PARSEMSGADDR
INDEX 3
PLDU 256
EQINT 0
PUSHCONT {
	; expValue
	; end expValue
	;; push identifier wallet_address
	PUSH S2
	; colValue
	NIP
	; end colValue
}
PUSHCONT {
	; expValue
	; end expValue
	;; push identifier sender_address
	PUSH S3
	; colValue
	NIP
	; end colValue
}
IFELSE
;; end if
;; if
;; push identifier is_outdated_tokens
PUSH S1
PUSHCONT {
	;; Remote call IRootTokenContract.deployWallet
	;; push identifier token_root_address
	GETGLOB 17
	NEWC
	STSLICECONST x62_
	STSLICE
	PUSHINT 109
	STZEROES
	STSLICECONST 0
	STSLICECONST 1
	NEWC
	STSLICECONST x66211c6f
	;; tokens
	;; push identifier tokens
	PUSH S8
	STUR 128
	;; deploy_grams
	;; push identifier settings_deploy_wallet_grams
	GETGLOB 19
	STUR 128
	;; wallet_public_key
	;; push identifier sender_public_key
	PUSH S6
	STUR 256
	;; owner_address
	;; push identifier sender_address
	PUSH S5
	STSLICER
	NEWC
	;; gas_back_address
	;; push identifier send_gas_to
	PUSH S3
	STSLICER
	STBREFR
	STBREFR
	ENDC
	PUSHINT 128
	SENDRAWMSG
}
PUSHCONT {
	;; transfer()
	;; push identifier send_gas_to
	DUP
	NEWC
	STSLICECONST x62_
	STSLICE
	PUSHINT 109
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	ENDC
	PUSHINT 128
	SENDRAWMSG
}
IFELSE
;; end if
BLKDROP 7
; end function burnCallbackV1
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	burnCallback
.public	burnCallback
.type	burnCallback, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
; Decode payload
;; decode TvmCell
DUP
SBITREFS
EQINT 1
SWAP
EQINT 0
AND
PUSHCONT {
	LDREF
	ENDS
	CTOS
}
IF
LDREF
; Decode sender_public_key
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode sender_address
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode 
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode send_gas_to
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: tokens
;; param: payload
;; param: sender_public_key
;; param: sender_address
;; param: 
;; param: send_gas_to
; function burnCallback
;; push identifier start_gas_balance
GETGLOB 20
;; get member balance
GETPARAM 7
INDEX 0
;; get member value
CALL $message_balance_macro$
;; -
SUB
UFITS 128
MAX
PUSHINT 2
RAWRESERVE
;; if
;; push identifier token_root_address
GETGLOB 17
;; get member sender
GETGLOB 9
SDEQ
PUSHCONT {
	;; push identifier tokens
	PUSH S5
	; expValue
	;; fetch burned_count
	GETGLOB 21
	; end expValue
	SWAP
	ADD
	UFITS 128
	; colValue
	SETGLOB 21
	; end colValue
	;; push identifier payload
	PUSH S4
	CTOS
	LDU 160
	; colValue
	DROP
	;; decl: ethereum_address
	;; emit TokenBurn
	NEWC
	PUSHSLICE xc0000000000000000000000002_
	STSLICER
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST x67ce8b37
	;; wid
	;; get member wid
	;; push identifier sender_address
	PUSH S4
	PARSEMSGADDR
	INDEX 2
	STIR 8
	;; addr
	;; get member value
	;; push identifier sender_address
	PUSH S4
	PARSEMSGADDR
	INDEX 3
	PLDU 256
	STUR 256
	;; tokens
	;; push identifier tokens
	PUSH S7
	STUR 128
	;; ethereum_address
	;; push identifier ethereum_address
	PUSH S1
	STUR 160
	ENDC
	PUSHINT 1
	SENDRAWMSG
	;; transfer()
	;; push identifier send_gas_to
	PUSH S1
	NEWC
	STSLICECONST x62_
	STSLICE
	PUSHINT 109
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	ENDC
	PUSHINT 128
	SENDRAWMSG
	DROP
}
PUSHCONT {
	FALSE
	;; decl: is_outdated_tokens
	; for
	PUSHINT 0
	;; decl: i
	PUSHCONT {
		;; push identifier i
		DUP
		;; get member length
		;; push identifier outdated_token_roots
		GETGLOB 12
		INDEX 0
		;; <
		LESS
	}
	PUSHCONT {
		; expValue
		; end expValue
		;; push identifier is_outdated_tokens
		PUSH S1
		;; short-circuiting ||
		DUP
		PUSHCONT {
			DROP
			;; index
			;; push identifier i
			DUP
			;; push identifier outdated_token_roots
			GETGLOB 12
			INDEX 1
			PUSHINT 32
			DICTUGET
			THROWIFNOT 50
			;; get member sender
			GETGLOB 9
			SDEQ
		}
		IFNOT
		; colValue
		POP S2
		; end colValue
		;; ++
		; expValue
		; end expValue
		INC
		; colValue
		; end colValue
	}
	WHILE
	DROP
	; end for
	;; if
	;; push identifier is_outdated_tokens
	DUP
	PUSHCONT {
		;; Remote call IRootTokenContract.deployWallet
		;; push identifier token_root_address
		GETGLOB 17
		NEWC
		STSLICECONST x62_
		STSLICE
		PUSHINT 109
		STZEROES
		STSLICECONST 0
		STSLICECONST 1
		NEWC
		STSLICECONST x66211c6f
		;; tokens
		;; push identifier tokens
		PUSH S8
		STUR 128
		;; deploy_grams
		;; push identifier settings_deploy_wallet_grams
		GETGLOB 19
		STUR 128
		;; wallet_public_key
		;; push identifier sender_public_key
		PUSH S6
		STUR 256
		;; owner_address
		;; push identifier sender_address
		PUSH S5
		STSLICER
		NEWC
		;; gas_back_address
		;; push identifier send_gas_to
		PUSH S4
		STSLICER
		STBREFR
		STBREFR
		ENDC
		PUSHINT 128
		SENDRAWMSG
	}
	PUSHCONT {
		;; transfer()
		;; push identifier send_gas_to
		PUSH S1
		NEWC
		STSLICECONST x62_
		STSLICE
		PUSHINT 109
		STZEROES
		STSLICECONST 0
		STSLICECONST 0
		ENDC
		PUSHINT 128
		SENDRAWMSG
	}
	IFELSE
	;; end if
	DROP
}
IFELSE
;; end if
BLKDROP 6
; end function burnCallback
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	transferMyTokensToEthereum
.public	transferMyTokensToEthereum
.type	transferMyTokensToEthereum, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
; Decode ethereum_address
LDUQ 160
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 160
}
IFNOT
ENDS
;; param: tokens
;; param: ethereum_address
; function transferMyTokensToEthereum
;; push identifier error_paused
GETGLOB 28
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; !
;; push identifier paused
GETGLOB 22
NOT
THROWANYIFNOT
;; push identifier tokens
PUSH S1
GTINT 0
THROWIFNOT 100
;; get member value
;; push identifier token_root_address
GETGLOB 17
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
THROWIFNOT 100
;; get member value
;; get member sender
GETGLOB 9
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
THROWIFNOT 100
;; get member value
CALL $message_balance_macro$
;; push identifier settings_burn_min_msg_value
GETGLOB 18
;; >=
GEQ
THROWIFNOT 100
ACCEPT
;; push identifier start_gas_balance
GETGLOB 20
;; get member balance
GETPARAM 7
INDEX 0
;; get member value
CALL $message_balance_macro$
;; -
SUB
UFITS 128
MAX
PUSHINT 2
RAWRESERVE
NEWC
;; decl: builder
; expValue
DUP
; end expValue
;; push identifier ethereum_address
PUSH S2
STUR 160
; colValue
NIP
; end colValue
;; push identifier builder
DUP
ENDC
;; decl: callback_payload
;; Remote call IBurnableByRootTokenRootContract.proxyBurn
;; push identifier token_root_address
GETGLOB 17
NEWC
STSLICECONST x62_
STSLICE
PUSHINT 109
STZEROES
STSLICECONST 0
STSLICECONST 1
NEWC
STSLICECONST x1df868a9
;; tokens
;; push identifier tokens
PUSH S5
STUR 128
;; sender_address
;; get member sender
GETGLOB 9
STSLICER
;; send_gas_to
;; get member sender
GETGLOB 9
STSLICER
NEWC
;; callback_address
MYADDR
STSLICER
;; callback_payload
;; push identifier callback_payload
PUSH S3
STREFR
STBREFR
STBREFR
ENDC
PUSHINT 128
SENDRAWMSG
BLKDROP 4
; end function transferMyTokensToEthereum
PUSHCONT {
	CALL $c7_to_c4$
}
IF
TRUE
SETGLOB 7

.globl	burnMyTokens
.public	burnMyTokens
.type	burnMyTokens, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
; Decode send_gas_to
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode callback_address
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode callback_payload
;; decode TvmCell
LDREF
ENDS
;; param: tokens
;; param: send_gas_to
;; param: callback_address
;; param: callback_payload
; function burnMyTokens
;; push identifier error_paused
GETGLOB 28
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; !
;; push identifier paused
GETGLOB 22
NOT
THROWANYIFNOT
;; push identifier tokens
PUSH S3
GTINT 0
THROWIFNOT 100
;; get member value
;; push identifier token_root_address
GETGLOB 17
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
THROWIFNOT 100
;; get member value
;; get member sender
GETGLOB 9
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
THROWIFNOT 100
;; get member value
CALL $message_balance_macro$
;; push identifier settings_burn_min_msg_value
GETGLOB 18
;; >=
GEQ
THROWIFNOT 100
ACCEPT
;; push identifier start_gas_balance
GETGLOB 20
;; get member balance
GETPARAM 7
INDEX 0
;; get member value
CALL $message_balance_macro$
;; -
SUB
UFITS 128
MAX
PUSHINT 2
RAWRESERVE
;; Remote call IBurnableByRootTokenRootContract.proxyBurn
;; push identifier token_root_address
GETGLOB 17
NEWC
STSLICECONST x62_
STSLICE
PUSHINT 109
STZEROES
STSLICECONST 0
STSLICECONST 1
NEWC
STSLICECONST x1df868a9
;; tokens
;; push identifier tokens
PUSH S5
STUR 128
;; sender_address
;; get member sender
GETGLOB 9
STSLICER
;; send_gas_to
;; push identifier send_gas_to
PUSH S4
STSLICER
NEWC
;; callback_address
;; push identifier callback_address
PUSH S4
STSLICER
;; callback_payload
;; push identifier callback_payload
PUSH S3
STREFR
STBREFR
STBREFR
ENDC
PUSHINT 128
SENDRAWMSG
BLKDROP 4
; end function burnMyTokens
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	withdrawExtraGasFromTokenRoot
.public	withdrawExtraGasFromTokenRoot
.type	withdrawExtraGasFromTokenRoot, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode to
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: to
; modifier onlyOwner
;; push identifier error_message_sender_is_not_my_owner
GETGLOB 23
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
; function isOwner
;; return
; function isInternalOwner
;; return
;; get member value
;; push identifier internal_owner_address
GETGLOB 14
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier internal_owner_address
	GETGLOB 14
	;; get member sender
	GETGLOB 9
	SDEQ
}
IF
; end function isInternalOwner
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	; function isExternalOwner
	;; return
	;; push identifier external_owner_pubkey
	GETGLOB 13
	NEQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier external_owner_pubkey
		GETGLOB 13
		GETGLOB 5
		DUP
		ISNULL
		PUSHCONT {
			DROP
			PUSHINT 0
		}
		IF
		;; ==
		EQUAL
	}
	IF
	; end function isExternalOwner
}
IFNOT
; end function isOwner
THROWANYIFNOT
; function withdrawExtraGasFromTokenRoot
ACCEPT
;; Remote call ISendSurplusGas.sendSurplusGas
;; push identifier token_root_address
GETGLOB 17
NEWC
STSLICECONST x62_
STSLICE
PUSHSLICE x3989680000000000000000000000000004_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST x20ebc76d
;; to
;; push identifier to
PUSH S1
STSLICER
ENDC
PUSHINT 1
SENDRAWMSG
; end function withdrawExtraGasFromTokenRoot
DROP
; end modifier onlyOwner
PUSHCONT {
	CALL $c7_to_c4$
}
IF
TRUE
SETGLOB 7

.globl	setPaused
.public	setPaused
.type	setPaused, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode value
LDI 1
ENDS
;; param: value
; modifier onlyOwner
;; push identifier error_message_sender_is_not_my_owner
GETGLOB 23
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
; function isOwner
;; return
; function isInternalOwner
;; return
;; get member value
;; push identifier internal_owner_address
GETGLOB 14
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier internal_owner_address
	GETGLOB 14
	;; get member sender
	GETGLOB 9
	SDEQ
}
IF
; end function isInternalOwner
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	; function isExternalOwner
	;; return
	;; push identifier external_owner_pubkey
	GETGLOB 13
	NEQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier external_owner_pubkey
		GETGLOB 13
		GETGLOB 5
		DUP
		ISNULL
		PUSHCONT {
			DROP
			PUSHINT 0
		}
		IF
		;; ==
		EQUAL
	}
	IF
	; end function isExternalOwner
}
IFNOT
; end function isOwner
THROWANYIFNOT
; function setPaused
ACCEPT
; expValue
; end expValue
;; push identifier value
DUP
; colValue
SETGLOB 22
; end colValue
;; Remote call IPausable.setPaused
;; push identifier token_root_address
GETGLOB 17
NEWC
STSLICECONST x62_
STSLICE
PUSHSLICE x3989680000000000000000000000000004_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST x0d5afc72
;; value
;; push identifier paused
GETGLOB 22
STIR 1
ENDC
PUSHINT 1
SENDRAWMSG
; end function setPaused
DROP
; end modifier onlyOwner
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	sendPausedCallbackTo
.public	sendPausedCallbackTo
.type	sendPausedCallbackTo, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode callback_id
LDU 64
; Decode callback_addr
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: callback_id
;; param: callback_addr
; function sendPausedCallbackTo
;; push identifier start_gas_balance
GETGLOB 20
;; get member balance
GETPARAM 7
INDEX 0
;; get member value
CALL $message_balance_macro$
;; -
SUB
UFITS 128
MAX
PUSHINT 2
RAWRESERVE
;; Remote call IPausedCallback.pausedCallback
;; push identifier callback_addr
DUP
NEWC
STSLICECONST x62_
STSLICE
PUSHINT 109
STZEROES
STSLICECONST 0
STSLICECONST 0
STSLICECONST x7386f0e8
;; callback_id
;; push identifier callback_id
PUSH S2
STUR 64
;; value
;; push identifier paused
GETGLOB 22
STIR 1
ENDC
PUSHINT 128
SENDRAWMSG
DROP2
; end function sendPausedCallbackTo
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	transferOwner
.public	transferOwner
.type	transferOwner, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode external_owner_pubkey_
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode internal_owner_address_
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: external_owner_pubkey_
;; param: internal_owner_address_
; modifier onlyOwner
;; push identifier error_message_sender_is_not_my_owner
GETGLOB 23
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
; function isOwner
;; return
; function isInternalOwner
;; return
;; get member value
;; push identifier internal_owner_address
GETGLOB 14
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier internal_owner_address
	GETGLOB 14
	;; get member sender
	GETGLOB 9
	SDEQ
}
IF
; end function isInternalOwner
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	; function isExternalOwner
	;; return
	;; push identifier external_owner_pubkey
	GETGLOB 13
	NEQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier external_owner_pubkey
		GETGLOB 13
		GETGLOB 5
		DUP
		ISNULL
		PUSHCONT {
			DROP
			PUSHINT 0
		}
		IF
		;; ==
		EQUAL
	}
	IF
	; end function isExternalOwner
}
IFNOT
; end function isOwner
THROWANYIFNOT
; function transferOwner
;; push identifier error_define_public_key_or_owner_address
GETGLOB 27
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; push identifier external_owner_pubkey_
PUSH S2
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member value
	;; push identifier internal_owner_address_
	PUSH S1
	PARSEMSGADDR
	INDEX 3
	PLDU 256
	EQINT 0
}
IF
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	;; push identifier external_owner_pubkey_
	PUSH S2
	EQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member value
		;; push identifier internal_owner_address_
		PUSH S1
		PARSEMSGADDR
		INDEX 3
		PLDU 256
		NEQINT 0
	}
	IF
}
IFNOT
THROWANYIFNOT
ACCEPT
; expValue
; end expValue
;; push identifier external_owner_pubkey_
PUSH S1
; colValue
SETGLOB 13
; end colValue
; expValue
; end expValue
;; push identifier internal_owner_address_
DUP
; colValue
SETGLOB 14
; end colValue
; end function transferOwner
DROP2
; end modifier onlyOwner
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	transferOwnership
.public	transferOwnership
.type	transferOwnership, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode target
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode external_owner_pubkey_
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode internal_owner_address_
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: target
;; param: external_owner_pubkey_
;; param: internal_owner_address_
; modifier onlyOwner
;; push identifier error_message_sender_is_not_my_owner
GETGLOB 23
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
; function isOwner
;; return
; function isInternalOwner
;; return
;; get member value
;; push identifier internal_owner_address
GETGLOB 14
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier internal_owner_address
	GETGLOB 14
	;; get member sender
	GETGLOB 9
	SDEQ
}
IF
; end function isInternalOwner
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	; function isExternalOwner
	;; return
	;; push identifier external_owner_pubkey
	GETGLOB 13
	NEQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier external_owner_pubkey
		GETGLOB 13
		GETGLOB 5
		DUP
		ISNULL
		PUSHCONT {
			DROP
			PUSHINT 0
		}
		IF
		;; ==
		EQUAL
	}
	IF
	; end function isExternalOwner
}
IFNOT
; end function isOwner
THROWANYIFNOT
; function transferOwnership
;; push identifier error_define_public_key_or_owner_address
GETGLOB 27
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
;; push identifier external_owner_pubkey_
PUSH S2
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member value
	;; push identifier internal_owner_address_
	PUSH S1
	PARSEMSGADDR
	INDEX 3
	PLDU 256
	EQINT 0
}
IF
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	;; push identifier external_owner_pubkey_
	PUSH S2
	EQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member value
		;; push identifier internal_owner_address_
		PUSH S1
		PARSEMSGADDR
		INDEX 3
		PLDU 256
		NEQINT 0
	}
	IF
}
IFNOT
THROWANYIFNOT
ACCEPT
;; Remote call ITransferOwner.transferOwner
;; push identifier target
PUSH S2
NEWC
STSLICECONST x62_
STSLICE
PUSHSLICE x3989680000000000000000000000000004_
STSLICER
STSLICECONST 0
STSLICECONST 1
NEWC
STSLICECONST x3828261a
;; external_owner_pubkey_
;; push identifier external_owner_pubkey_
PUSH S3
STUR 256
;; internal_owner_address_
;; push identifier internal_owner_address_
PUSH S2
STSLICER
STBREFR
ENDC
PUSHINT 1
SENDRAWMSG
; end function transferOwnership
BLKDROP 3
; end modifier onlyOwner
PUSHCONT {
	CALL $c7_to_c4$
}
IF
TRUE
SETGLOB 7

.globl	setTokenRootAddressOnce
.public	setTokenRootAddressOnce
.type	setTokenRootAddressOnce, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode value
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: value
; modifier onlyOwner
;; push identifier error_message_sender_is_not_my_owner
GETGLOB 23
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
; function isOwner
;; return
; function isInternalOwner
;; return
;; get member value
;; push identifier internal_owner_address
GETGLOB 14
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier internal_owner_address
	GETGLOB 14
	;; get member sender
	GETGLOB 9
	SDEQ
}
IF
; end function isInternalOwner
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	; function isExternalOwner
	;; return
	;; push identifier external_owner_pubkey
	GETGLOB 13
	NEQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier external_owner_pubkey
		GETGLOB 13
		GETGLOB 5
		DUP
		ISNULL
		PUSHCONT {
			DROP
			PUSHINT 0
		}
		IF
		;; ==
		EQUAL
	}
	IF
	; end function isExternalOwner
}
IFNOT
; end function isOwner
THROWANYIFNOT
; function setTokenRootAddressOnce
;; get member value
;; push identifier token_root_address
GETGLOB 17
PARSEMSGADDR
INDEX 3
PLDU 256
EQINT 0
THROWIFNOT 100
ACCEPT
; expValue
; end expValue
;; push identifier value
DUP
; colValue
SETGLOB 17
; end colValue
; end function setTokenRootAddressOnce
DROP
; end modifier onlyOwner
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	setEthEventDeployPubkeyOnce
.public	setEthEventDeployPubkeyOnce
.type	setEthEventDeployPubkeyOnce, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode value
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
ENDS
;; param: value
; modifier onlyOwner
;; push identifier error_message_sender_is_not_my_owner
GETGLOB 23
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
; function isOwner
;; return
; function isInternalOwner
;; return
;; get member value
;; push identifier internal_owner_address
GETGLOB 14
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier internal_owner_address
	GETGLOB 14
	;; get member sender
	GETGLOB 9
	SDEQ
}
IF
; end function isInternalOwner
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	; function isExternalOwner
	;; return
	;; push identifier external_owner_pubkey
	GETGLOB 13
	NEQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier external_owner_pubkey
		GETGLOB 13
		GETGLOB 5
		DUP
		ISNULL
		PUSHCONT {
			DROP
			PUSHINT 0
		}
		IF
		;; ==
		EQUAL
	}
	IF
	; end function isExternalOwner
}
IFNOT
; end function isOwner
THROWANYIFNOT
; function setEthEventDeployPubkeyOnce
;; push identifier ethereum_event_deploy_pubkey
GETGLOB 15
EQINT 0
THROWIFNOT 100
ACCEPT
; expValue
; end expValue
;; push identifier value
DUP
; colValue
SETGLOB 15
; end colValue
; end function setEthEventDeployPubkeyOnce
DROP
; end modifier onlyOwner
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	setEthEventConfigAddressOnce
.public	setEthEventConfigAddressOnce
.type	setEthEventConfigAddressOnce, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode value
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: value
; modifier onlyOwner
;; push identifier error_message_sender_is_not_my_owner
GETGLOB 23
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
; function isOwner
;; return
; function isInternalOwner
;; return
;; get member value
;; push identifier internal_owner_address
GETGLOB 14
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier internal_owner_address
	GETGLOB 14
	;; get member sender
	GETGLOB 9
	SDEQ
}
IF
; end function isInternalOwner
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	; function isExternalOwner
	;; return
	;; push identifier external_owner_pubkey
	GETGLOB 13
	NEQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier external_owner_pubkey
		GETGLOB 13
		GETGLOB 5
		DUP
		ISNULL
		PUSHCONT {
			DROP
			PUSHINT 0
		}
		IF
		;; ==
		EQUAL
	}
	IF
	; end function isExternalOwner
}
IFNOT
; end function isOwner
THROWANYIFNOT
; function setEthEventConfigAddressOnce
;; get member value
;; push identifier ethereum_event_configuration_address
GETGLOB 16
PARSEMSGADDR
INDEX 3
PLDU 256
EQINT 0
THROWIFNOT 100
ACCEPT
; expValue
; end expValue
;; push identifier value
DUP
; colValue
SETGLOB 16
; end colValue
; end function setEthEventConfigAddressOnce
DROP
; end modifier onlyOwner
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	setBurnMinMsgValue
.public	setBurnMinMsgValue
.type	setBurnMinMsgValue, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode value
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: value
; modifier onlyOwner
;; push identifier error_message_sender_is_not_my_owner
GETGLOB 23
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
; function isOwner
;; return
; function isInternalOwner
;; return
;; get member value
;; push identifier internal_owner_address
GETGLOB 14
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier internal_owner_address
	GETGLOB 14
	;; get member sender
	GETGLOB 9
	SDEQ
}
IF
; end function isInternalOwner
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	; function isExternalOwner
	;; return
	;; push identifier external_owner_pubkey
	GETGLOB 13
	NEQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier external_owner_pubkey
		GETGLOB 13
		GETGLOB 5
		DUP
		ISNULL
		PUSHCONT {
			DROP
			PUSHINT 0
		}
		IF
		;; ==
		EQUAL
	}
	IF
	; end function isExternalOwner
}
IFNOT
; end function isOwner
THROWANYIFNOT
; function setBurnMinMsgValue
ACCEPT
; expValue
; end expValue
;; push identifier value
DUP
; colValue
SETGLOB 18
; end colValue
; end function setBurnMinMsgValue
DROP
; end modifier onlyOwner
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	setDeployWalletGrams
.public	setDeployWalletGrams
.type	setDeployWalletGrams, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode value
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: value
; modifier onlyOwner
;; push identifier error_message_sender_is_not_my_owner
GETGLOB 23
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
; function isOwner
;; return
; function isInternalOwner
;; return
;; get member value
;; push identifier internal_owner_address
GETGLOB 14
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier internal_owner_address
	GETGLOB 14
	;; get member sender
	GETGLOB 9
	SDEQ
}
IF
; end function isInternalOwner
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	; function isExternalOwner
	;; return
	;; push identifier external_owner_pubkey
	GETGLOB 13
	NEQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier external_owner_pubkey
		GETGLOB 13
		GETGLOB 5
		DUP
		ISNULL
		PUSHCONT {
			DROP
			PUSHINT 0
		}
		IF
		;; ==
		EQUAL
	}
	IF
	; end function isExternalOwner
}
IFNOT
; end function isOwner
THROWANYIFNOT
; function setDeployWalletGrams
ACCEPT
; expValue
; end expValue
;; push identifier value
DUP
; colValue
SETGLOB 19
; end colValue
; end function setDeployWalletGrams
DROP
; end modifier onlyOwner
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	setEthereumEventCode
.public	setEthereumEventCode
.type	setEthereumEventCode, @function
GETGLOB 1
ISNULL
PUSHCONT {
	CALL $c4_to_c7$
}
IF
; Decode input parameters
; Decode value
;; decode TvmCell
LDREF
ENDS
;; param: value
; modifier onlyOwner
;; push identifier error_message_sender_is_not_my_owner
GETGLOB 23
DUP
LESSINT 2
PUSHCONT {
	DROP
	PUSHINT 100
}
IF
; function isOwner
;; return
; function isInternalOwner
;; return
;; get member value
;; push identifier internal_owner_address
GETGLOB 14
PARSEMSGADDR
INDEX 3
PLDU 256
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier internal_owner_address
	GETGLOB 14
	;; get member sender
	GETGLOB 9
	SDEQ
}
IF
; end function isInternalOwner
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	; function isExternalOwner
	;; return
	;; push identifier external_owner_pubkey
	GETGLOB 13
	NEQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier external_owner_pubkey
		GETGLOB 13
		GETGLOB 5
		DUP
		ISNULL
		PUSHCONT {
			DROP
			PUSHINT 0
		}
		IF
		;; ==
		EQUAL
	}
	IF
	; end function isExternalOwner
}
IFNOT
; end function isOwner
THROWANYIFNOT
; function setEthereumEventCode
ACCEPT
; expValue
; end expValue
;; push identifier value
DUP
; colValue
SETGLOB 11
; end colValue
; end function setEthereumEventCode
DROP
; end modifier onlyOwner
CALL $c7_to_c4$
TRUE
SETGLOB 7

.globl	c7_to_c4
.type	c7_to_c4, @function
GETGLOB 2
NEWC
STU 256
GETGLOB 3
STUR 64
GETGLOB 6
STUR 1
NEWC
GETGLOB 14
GETGLOB 15
GETGLOB 16
GETGLOB 19
GETGLOB 26
GETGLOB 27
GETGLOB 28
REVERSE 8, 0
STSLICE
STU 256
STSLICE
STU 128
STU 8
STU 8
STU 8
NEWC
GETGLOB 17
GETGLOB 20
GETGLOB 21
REVERSE 4, 0
STSLICE
STU 128
STU 128
GETGLOB 10
GETGLOB 11
GETGLOB 12
UNTUPLE 2
GETGLOB 13
GETGLOB 18
GETGLOB 22
GETGLOB 23
GETGLOB 24
GETGLOB 25
REVERSE 13, 0
STBREF
STBREF
STU 256
STREF
STU 32
STDICT
STU 256
STU 128
STI 1
STU 8
STU 8
STU 8
ENDC
POP C4

.globl	c4_to_c7
.type	c4_to_c7, @function
PUSHROOT
CTOS        ; c4
LDU 256      ; pubkey c4
LDU 64      ; pubkey timestamp c4
LDU 1       ; pubkey [timestamp] constructor_flag memory
LDREFRTOS
LDMSGADDR
LDU 256
LDMSGADDR
LDU 128
LDU 8
LDU 8
PLDU 8
SETGLOB 28
SETGLOB 27
SETGLOB 26
SETGLOB 19
SETGLOB 16
SETGLOB 15
SETGLOB 14
LDREFRTOS
LDMSGADDR
LDU 128
PLDU 128
SETGLOB 21
SETGLOB 20
SETGLOB 17
LDU 256
LDREF
LDU 32
LDDICT
ROTREV
PAIR
SETGLOB 12
LDU 256
LDU 128
LDI 1
LDU 8
LDU 8
PLDU 8
SETGLOB 25
SETGLOB 24
SETGLOB 23
SETGLOB 22
SETGLOB 18
SETGLOB 13
SETGLOB 11
SETGLOB 10
TRUE
SETGLOB 1   ; pubkey [timestamp] constructor_flag
SETGLOB 6   ; pubkey [timestamp]
SETGLOB 3   ; D
SETGLOB 2

.macro c4_to_c7_with_init_storage
PUSHROOT
CTOS        ; c4
DUP        ; c4 c4
SBITS      ; c4 bits
GTINT 1    ; c4 bits>1
PUSHCONT {
	LDU 256      ; pubkey c4
	LDU 64      ; pubkey timestamp c4
	LDU 1       ; pubkey [timestamp] constructor_flag memory
	LDREFRTOS
	LDMSGADDR
	LDU 256
	LDMSGADDR
	LDU 128
	LDU 8
	LDU 8
	PLDU 8
	SETGLOB 28
	SETGLOB 27
	SETGLOB 26
	SETGLOB 19
	SETGLOB 16
	SETGLOB 15
	SETGLOB 14
	LDREFRTOS
	LDMSGADDR
	LDU 128
	PLDU 128
	SETGLOB 21
	SETGLOB 20
	SETGLOB 17
	LDU 256
	LDREF
	LDU 32
	LDDICT
	ROTREV
	PAIR
	SETGLOB 12
	LDU 256
	LDU 128
	LDI 1
	LDU 8
	LDU 8
	PLDU 8
	SETGLOB 25
	SETGLOB 24
	SETGLOB 23
	SETGLOB 22
	SETGLOB 18
	SETGLOB 13
	SETGLOB 11
	SETGLOB 10
	TRUE
	SETGLOB 1   ; pubkey [timestamp] constructor_flag
	SETGLOB 6   ; pubkey [timestamp]
	SETGLOB 3   ; D
	SETGLOB 2
}
PUSHCONT {
	PLDDICT   ; D
	; init _randomNonce
	PUSHINT 1
	PUSH S1
	PUSHINT 64
	DICTUGET
	PUSHCONT {
		PLDU 256
	}
	PUSHCONT {
		PUSHINT 0
	}
	IFELSE
	SETGLOB 10
	; init ethereum_event_code
	PUSHINT 2
	PUSH S1
	PUSHINT 64
	DICTUGETREF
	PUSHCONT {
		NEWC
		ENDC
	}
	IFNOT
	SETGLOB 11
	; init outdated_token_roots
	PUSHINT 3
	PUSH S1
	PUSHINT 64
	DICTUGET
	PUSHCONT {
		LDU 32
		PLDDICT
		PAIR
	}
	PUSHCONT {
		PUSHINT 0
		NEWDICT
		PAIR
	}
	IFELSE
	SETGLOB 12
	; init external_owner_pubkey
	PUSHINT 0
	SETGLOB 13
	; init internal_owner_address
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 14
	; init ethereum_event_deploy_pubkey
	PUSHINT 0
	SETGLOB 15
	; init ethereum_event_configuration_address
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 16
	; init token_root_address
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 17
	; init settings_burn_min_msg_value
	PUSHINT 0
	SETGLOB 18
	; init settings_deploy_wallet_grams
	PUSHINT 0
	SETGLOB 19
	; init start_gas_balance
	PUSHINT 0
	SETGLOB 20
	; init burned_count
	PUSHINT 0
	SETGLOB 21
	; init paused
	PUSHINT 0
	SETGLOB 22
	; init error_message_sender_is_not_my_owner
	PUSHINT 0
	SETGLOB 23
	; init error_message_sender_is_not_my_root
	PUSHINT 0
	SETGLOB 24
	; init error_message_sender_is_not_valid_event
	PUSHINT 0
	SETGLOB 25
	; init error_message_not_valid_payload
	PUSHINT 0
	SETGLOB 26
	; init error_define_public_key_or_owner_address
	PUSHINT 0
	SETGLOB 27
	; init error_paused
	PUSHINT 0
	SETGLOB 28
	; set contract pubkey
	PUSHINT 0
	SWAP
	PUSHINT 64
	DICTUGET
	THROWIFNOT 61
	PLDU 256
	SETGLOB 2
	PUSHINT 0 ; timestamp
	SETGLOB 3
	PUSHINT 0 ; constructor_flag
	SETGLOB 6
	TRUE
	SETGLOB 1
	;; init state var: settings_burn_min_msg_value
	PUSHINT 1000000000
	SETGLOB 18
	;; init state var: settings_deploy_wallet_grams
	PUSHINT 50000000
	SETGLOB 19
	;; init state var: paused
	FALSE
	SETGLOB 22
	;; init state var: error_message_sender_is_not_my_owner
	PUSHINT 100
	SETGLOB 23
	;; init state var: error_message_sender_is_not_my_root
	PUSHINT 102
	SETGLOB 24
	;; init state var: error_message_sender_is_not_valid_event
	PUSHINT 103
	SETGLOB 25
	;; init state var: error_message_not_valid_payload
	PUSHINT 104
	SETGLOB 26
	;; init state var: error_define_public_key_or_owner_address
	PUSHINT 106
	SETGLOB 27
	;; init state var: error_paused
	PUSHINT 107
	SETGLOB 28
}
IFELSE

.internal-alias :main_internal,        0
.internal	:main_internal
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: main_internal
;; param: contract_balance
;; param: msg_balance
;; param: int_msg_info
;; param: msg_body_slice
PUSHINT 0  ; main_external trans id
PUSH S2
CTOS
LDU 4       ; bounced tail
LDMSGADDR   ; bounced src tail
DROP
SETGLOB 9
MODPOW2 1
IFRET
PUSH S1    ; body
SEMPTY     ; isEmpty
IFRET
PUSH S1 ; body
LDU 32  ; funcId body'
PUSH S1 ; funcId body' funcId
IFNOTRET
PUSH S1 ; funcId body' funcId
LESSINT 3            ; funcId body' funcId<3
PUSH S2              ; funcId body' funcId<3 funcId
PUSHINT 4294967293   ; funcId body' funcId<3 funcId 4294967293
GREATER              ; funcId body' funcId<3 funcId>4294967293
OR                   ; funcId body' funcId<3||funcId>4294967293
PUSHCONT {
	DROP2
	THROW 60
}
IFJMP
SWAP    ; body funcId
CALL 1
GETGLOB 7
ISNULL
PUSHCONT {
	DROP
	THROW 60
}
IF

.internal-alias :main_external,        -1
.internal	:main_external
PUSHINT -1 ; main_external trans id
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
SETGLOB 9
PUSH S1
CALL $c4_to_c7_with_init_storage$
LDU 1 ; haveSign msgSlice
SWAP
PUSHCONT {
	PUSHINT 512
	LDSLICEX ; signatureSlice msgSlice
	DUP      ; signatureSlice msgSlice msgSlice
	HASHSU   ; signatureSlice msgSlice hashMsgSlice
	SWAP  ; signatureSlice hashMsgSlice msgSlice
	LDU 1 ; signatureSlice hashMsgSlice havePubkey msgSlice
	SWAP  ; signatureSlice hashMsgSlice msgSlice havePubkey
	PUSHCONT {
		LDU 256       ; signatureSlice hashMsgSlice pubkey msgSlice
		XCHG s3
		SWAP
	}
	PUSHCONT {
		XCHG s2
		GETGLOB 2
	}
	IFELSE
	DUP
	SETGLOB 5
	CHKSIGNU      ; msgSlice isSigned
	THROWIFNOT 40 ; msgSlice
}
PUSHCONT {
	LDU 1      ; havePubkey msgSlice
	SWAP       ; msgSlice havePubkey
	THROWIF 58 ; msgSlice
}
IFELSE
LDU 64                         ; timestamp msgSlice
SWAP                           ; msgSlice timestamp
CALL $replay_protection_macro$ ; msgSlice
LDU 32  ; expireAt msgSlice
SWAP    ; msgSlice expireAt
NOW     ; msgSlice expireAt now
GREATER ; msgSlice expireAt>now
THROWIFNOT 57
LDU  32 ; funcId body
PUSH S1 ; funcId body funcId
LESSINT 3            ; funcId body' funcId<3
PUSH S2              ; funcId body' funcId<3 funcId
PUSHINT 4294967293   ; funcId body' funcId<3 funcId 4294967293
GREATER              ; funcId body' funcId<3 funcId>4294967293
OR                   ; funcId body' funcId<3||funcId>4294967293
PUSHCONT {
	DROP2
	THROW 60
}
IFJMP
SWAP    ; body funcId
CALL 1
GETGLOB 7
ISNULL
PUSHCONT {
	DROP
	THROW 60
}
IF

.globl	external_owner_pubkey
.public	external_owner_pubkey
.type	external_owner_pubkey, @function
CALL $c4_to_c7$
GETGLOB 13
NEWC
PUSHSLICE xc0000000000000000000000002_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST xcdf1df2f
PUSH S1
STUR 256
ENDC
PUSHINT 1
SENDRAWMSG
TRUE
SETGLOB 7

.globl	internal_owner_address
.public	internal_owner_address
.type	internal_owner_address, @function
CALL $c4_to_c7$
GETGLOB 14
NEWC
PUSHSLICE xc0000000000000000000000002_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST xa98bad2a
PUSH S1
STSLICER
ENDC
PUSHINT 1
SENDRAWMSG
TRUE
SETGLOB 7

.globl	ethereum_event_deploy_pubkey
.public	ethereum_event_deploy_pubkey
.type	ethereum_event_deploy_pubkey, @function
CALL $c4_to_c7$
GETGLOB 15
NEWC
PUSHSLICE xc0000000000000000000000002_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST xdc31fe95
PUSH S1
STUR 256
ENDC
PUSHINT 1
SENDRAWMSG
TRUE
SETGLOB 7

.globl	ethereum_event_configuration_address
.public	ethereum_event_configuration_address
.type	ethereum_event_configuration_address, @function
CALL $c4_to_c7$
GETGLOB 16
NEWC
PUSHSLICE xc0000000000000000000000002_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST xf68d1c31
PUSH S1
STSLICER
ENDC
PUSHINT 1
SENDRAWMSG
TRUE
SETGLOB 7

.globl	token_root_address
.public	token_root_address
.type	token_root_address, @function
CALL $c4_to_c7$
GETGLOB 17
NEWC
PUSHSLICE xc0000000000000000000000002_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST xedf12b93
PUSH S1
STSLICER
ENDC
PUSHINT 1
SENDRAWMSG
TRUE
SETGLOB 7

.globl	settings_burn_min_msg_value
.public	settings_burn_min_msg_value
.type	settings_burn_min_msg_value, @function
CALL $c4_to_c7$
GETGLOB 18
NEWC
PUSHSLICE xc0000000000000000000000002_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST xbff6c029
PUSH S1
STUR 128
ENDC
PUSHINT 1
SENDRAWMSG
TRUE
SETGLOB 7

.globl	settings_deploy_wallet_grams
.public	settings_deploy_wallet_grams
.type	settings_deploy_wallet_grams, @function
CALL $c4_to_c7$
GETGLOB 19
NEWC
PUSHSLICE xc0000000000000000000000002_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST xb4696dbd
PUSH S1
STUR 128
ENDC
PUSHINT 1
SENDRAWMSG
TRUE
SETGLOB 7

.globl	start_gas_balance
.public	start_gas_balance
.type	start_gas_balance, @function
CALL $c4_to_c7$
GETGLOB 20
NEWC
PUSHSLICE xc0000000000000000000000002_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST xf26e937f
PUSH S1
STUR 128
ENDC
PUSHINT 1
SENDRAWMSG
TRUE
SETGLOB 7

.globl	burned_count
.public	burned_count
.type	burned_count, @function
CALL $c4_to_c7$
GETGLOB 21
NEWC
PUSHSLICE xc0000000000000000000000002_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST xf481fc8d
PUSH S1
STUR 128
ENDC
PUSHINT 1
SENDRAWMSG
TRUE
SETGLOB 7

.globl	paused
.public	paused
.type	paused, @function
CALL $c4_to_c7$
GETGLOB 22
NEWC
PUSHSLICE xc0000000000000000000000002_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST xb08d66d1
PUSH S1
STIR 1
ENDC
PUSHINT 1
SENDRAWMSG
TRUE
SETGLOB 7

